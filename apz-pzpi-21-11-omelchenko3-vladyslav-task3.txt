1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Метою створення цієї програмної системи є автоматизація процесів управління спортивними залами та моніторингу їх умов. Вона розроблена на мові Python за допомогою фреймворку Django для розробки REST API, що відповідає за взаємодію між сервером та клієнтськими інтерфейсами. Дані передаються через HTTP протокол, причому кожен метод API має свій унікальний URL і набір параметрів. Формат даних, що обмінюються між клієнтом і сервером, є JSON. REST API було обрано, тому що він є досить нескладним у реалізації та він дуже гарно масштабується, що робить можливим інтеграцію різноманітних клієнтських додатків, таких як веб-інтерфейс, мобільні додатки та IoT-пристрої.
Фронтенд системи, який розроблено з використанням React і збирача Node, комунікує з сервером за допомогою REST API через надсилання та отримання даних у форматі JSON, що дозволяє швидко і зручно створювати різноманітні інтерфейси користувача, здатні до динамічних оновлень залежно від даних на сервері.
IoT-пристрої використовуються для контролю температури, вологості та рівня шуму в спортивних залах. Вони так само взаємодіють із системою завдяки REST API. Ці пристрої передають дані на сервер для їх подальшої обробки. Це дозволяє швидко та зручно стежити за станом зон залів.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Беручи до уваги складність програмної системи, важливо чітко розуміти, як її численні компоненти взаємодіють один з одним. Серверна частина безпосередньо інтегрована з базою даних, що дозволяє виконувати такі ключові операції, як отримання, створення, оновлення та видалення даних. 
Пристрої IoT, які є невід'ємною частиною системи, взаємодіють із сервером через HTTP-запити. Перед початком роботи кожен пристрій проходить автентифікацію, що гарантує безпечну передачу даних і контроль доступу, забезпечуючи захист інформації від несанкціонованого доступу.
Веб-клієнт, що є центральним елементом користувацького інтерфейсу, побудований на основі чітко структурованої системи HTTP-запитів, що дозволяє ефективно і безпечно взаємодіяти із серверними ресурсами. Кожен запит, надісланий із веб-клієнта, проходить ретельну перевірку, що гарантує надійний доступ до серверних функцій і забезпечує максимальну ефективність роботи системи. Завдяки компонентній архітектурі веб-клієнт забезпечує глибоку інтеграцію між різними елементами інтерфейсу, що сприяє плавній і стабільній роботі додатку.
Крім того, у React був розроблений модуль «utils», що виконує спеціалізовані функції. Цей модуль містить різні утиліти, які спрощують процес розробки та дозволяють використовувати код повторно в різних частинах додатка, що підвищує гнучкість і масштабованість веб-клієнта. Такий підхід не лише покращує продуктивність системи, але й робить її підтримку більш зручною в майбутньому.
На діаграмі розгортання відображена логічна структура програмної системи, включаючи основні технології, що застосовуються, а також детально описані принципи взаємодії між її компонентами і їх інтеграція (рис. 2.2):

3 ОПИС АРХІТЕКТУРИ IOT ЧАСТИНИ

Arduino IDE було обрано як основне середовище розробки завдяки кільком ключовим перевагам. По-перше, це середовище надає широкий спектр бібліотек, які значно спрощують роботу з різними модулями та датчиками. Наприклад, для роботи з DHT22 використовувалася спеціалізована бібліотека, що забезпечує простий інтерфейс для зчитування показників температури та вологості. По-друге, Arduino IDE має інтуїтивно зрозумілий інтерфейс, який дозволяє швидко завантажувати код на мікроконтролер і налагоджувати його, що є критичним у процесі розробки вбудованих систем.
Окрім того, структура проекту передбачає взаємодію між серверною частиною та IoT-компонентами. На діаграмі компонентів, яка наведена на рис. 2.1, показано, як мікроконтролер ESP32, оснащений датчиками, передає зібрані дані на сервер для подальшої обробки. Сервер, у свою чергу, аналізує ці дані і, в залежності від отриманих результатів, може виконувати певні дії або повідомляти користувачів про важливі події.
Використання мікроконтролера ESP32 разом із Arduino IDE та мовою програмування C++ дозволило створити ефективну та надійну систему збору та передачі даних, що є важливим елементом загальної архітектури проекту. Ці рішення забезпечують високу продуктивність, гнучкість і масштабованість IoT-системи, що відповідає вимогам сучасних технологічних рішень.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

У межах цієї предметної області передбачено чотири категорії користувачів. Перша категорія — це неавторизовані користувачі, які мають можливість через веб-інтерфейс лише зареєструвати новий обліковий запис або увійти до системи, використовуючи вже існуючий. Функціональні вимоги, що стосуються цього типу користувачів, абсолютно відповідають їхнім потребам і представлені на діаграмі прецедентів на (рис. 1.1):
До другої категорії належить тренер, який за допомогою веб-клієнту може переглядати зали, у яких він працює, переглядати інформацію про них, включаючи їхні зони та керувати тренуваннями там, а саме: додавати їх, редагувати та видаляти. Також він має можливість переглядати показники датчиків у зонах залу, що є дуже зручним та допомагає тренеру у роботі. Функціональні потреби цієї категорії користувачів відповідають обсягу роботи тренерів та їх наведено у діаграмі прецедентів (рис. 1.2):
До третьої категорії належать власники залів, які, з використанням веб-клієнту можуть керувати залами, а саме: додавати їх, редагувати чи видаляти, розміщати зони у залах, а також наймати тренерів та звільняти їх. Власники повністю керують роботою тренерів. Їхні функціональні потреби відповідають функціям, необхідним для адміністраторів залів та наведені у діаграмі прецедентів (рис. 1.3):
До четвертої категорії належать клієнти залів. Вони можуть переглядати список існуючих залів та інформацію про них та записуватися на тренування. Їхні функціональні потреби повністю відповідають функціям, необхідним для клієнтів та наведені на діаграмі прецедентів (рис. 1.4):
До останньої п’ятої категорії належить адміністратор БД, який має можливість взаємодіяти з базою даних програмної системи. Він забезпечує цілісність та актуальність даних завдяки повному доступу до керування даними. Його функціональні потреби повністю відповідають функціям, необхідним для адміністраторів та наведені на діаграмі прецедентів (рис. 1.5):
У процесі концептуального моделювання предметної області було визначено ключові типи користувачів цієї програмної системи та їхні функціональні можливості, які були докладно описано й візуалізовано у вигляді діаграм прецедентів.

5 ПОБУДОВА ДІАГРАМИ СТАНІВ

Якщо користувач входить у систему як власник залу, його перенаправляють на головну сторінку власника. Після авторизації йому також доступна функція виходу з акаунту. На головній сторінці власника відображається посилання на список всіх його залів з інформацією про кожного з них. Там власник може додати новий зал, відредагувати чи видалити існуючий. Також він може перейти на сторінку всіх зон залу чи на сторінку всіх тренерів залу. На сторінці зон він зможе переглянути інформацію про них, а також додати нову, відредагувати чи видалити існуючу. На сторінці зон власник може переглянути список тренувань у зоні, а також за наявності переглянути дані датчика. На сторінці тренерів залу власник може переглянути всіх тренерів, що працюють у цьому залі, додати нового чи звільнити існуючого. Діаграма станів, що показує взаємодію адміністратора з веб-клієнтом, наведена на рис. 2.3:
Якщо користувач входить у систему як тренер, його перенаправляють на головну сторінку тренера. Після авторизації йому доступна функція виходу з акаунту. На головній сторінці тренера розташоване меню з двома посиланнями, які змінюють контент сторінки відповідно до вибору користувача. За першим посиланням тренер отримує можливість переглянути список тренувань, які він проводить, а також основну інформацію про ці тренування. Крім того, він може додати нове тренування у будь-якому залі, де він працює, відредагувати чи видалити існуюче. Друге посилання відкриває список залів, у яких тренер працює. Там тренер може переглянути інформацію про зали, тренування у залі, переглянути зони чи звільнитися. При перегляді зон тренер також може переглянути список тренувань там, додати нове, відредагувати чи видалити існуюче, як і при перегляді тренувань у залі. Також він може за наявності перевірити показники датчика. Діаграма станів, що показує взаємодію тренера з веб-клієнтом, наведена на рис. 2.4:
Якщо користувач входить у систему як клієнт, його перенаправляють на головну сторінку клієнта. Після авторизації йому доступна функція виходу з акаунту. На головній сторінці тренера розташоване меню з двома посиланнями, які змінюють контент сторінки відповідно до вибору користувача. За першим посиланням користувач отримує можливість переглянути свої записи на тренування та за бажанням відмінити певні з них. За другим посиланням користувач відкриває список усіх залів додатку. Він може переглянути їх, переглянути тренування цих залів, записатися на деякі з них чи, навпаки, відписатися з деяких. Діаграма станів, що показує взаємодію клієнта з веб-клієнтом, наведена на рис. 2.5:

6 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Клієнтська частина проекту розроблена з використанням React JS, який виступає основним інструментом для створення фронтенд-інтерфейсів. React JS забезпечує розробників багатим набором функцій і можливостей, що дозволяють створювати сучасні та продуктивні клієнтські додатки. Для зв’язку з сервером використовуються HTTP-запити до REST API, які надсилаються на певні маршрути для подальшої обробки. 
Архітектура React базується на компонентному підході, який дає змогу будувати інтерфейси шляхом поєднання невеликих, багаторазово використовуваних блоків. Це значно спрощує процес розробки та забезпечує легкість у підтримці великих проектів. Крім того, React застосовує віртуальний DOM, що дозволяє ефективно оновлювати інтерфейс у разі змін даних, тим самим підвищуючи продуктивність і швидкість роботи додатка. Однією з основних переваг React є використання віртуального DOM, що робить його ідеальним рішенням для розробки односторінкових додатків (SPA). У таких додатках вся необхідна інформація завантажується під час першого запуску, а навігація здійснюється без повторного завантаження сторінок, що забезпечує плавний і швидкий користувацький досвід.
React також має одну з найбільших і найрозвиненіших екосистем серед усіх доступних фронтенд-інструментів. Завдяки компонентній структурі, використанню віртуального DOM і потужній екосистемі, React є одним із найефективніших варіантів для розробки клієнтських веб-додатків. На діаграмі компонентів представлено структуру веб-клієнта та його взаємодію з іншими елементами системи (рис. 2.1):

ВИСНОВКИ

Під час виконання лабораторної роботи було розроблено клієнтську частину для програмної системи для автоматизації управління спортивними залами та моніторингу умов.

ДОДАТОК В
Файл scanner.ino


#include <WiFi.h>
#include <HTTPClient.h>
#include "DHTesp.h"

const char* SSID = "Wokwi-GUEST";
const char* PASSWORD = "";

const int DHT_PIN = 18; 
const int micPin = 35;  
DHTesp dhtSensor; 

float measureNoiseLevel() {
  int noiseLevel = analogRead(micPin);
  float noiseLevelDb = (noiseLevel / 4096.0) * 100.0; 
  return noiseLevelDb;
}

void setup() {
  Serial.begin(115200);
  dhtSensor.setup(DHT_PIN, DHTesp::DHT22); 
  WiFi.begin(SSID, PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
  }
}

void loop() {
  float noiseLevelDb = measureNoiseLevel();
  Serial.print("Noise Level: ");
  Serial.print(noiseLevelDb);
  Serial.println(" dB");

  TempAndHumidity data = dhtSensor.getTempAndHumidity();
  Serial.print("Temperature: ");
  Serial.print(data.temperature, 2);
  Serial.print("°C, Humidity: ");
  Serial.print(data.humidity, 1);
  Serial.println("%");

  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin("http://localhost:8000/get_sensor_data");
    http.addHeader("Content-Type", "application/json");
    
    String jsonData = "{\"sensor_id\":14, \"Temperature\":" + String(data.temperature, 2) + 
                      ", \"Humidity\":" + String(data.humidity, 1) + 
                      ", \"Noise\":" + String(noiseLevelDb) + "}";
    
    int httpResponseCode = http.POST(jsonData);
    if (httpResponseCode > 0) {
      String response = http.getString();
      Serial.println(httpResponseCode);
      Serial.println(response);
    } else {
      Serial.print("Error on sending POST: ");
      Serial.println(httpResponseCode);
    }
    http.end();
  } else {
    Serial.println("Error in WiFi connection");
  }

  delay(5000); 
}